---
title: "Examen_licenciatura_137926_148792"
author: "Alvaro Casillas y Ricardo Lara"
date: "12/6/2017"
output: html_document
---

```{r echo=TRUE, warning=FALSE, error=FALSE, message=FALSE}
library(readr)
library(ggplot2)
library(stringr)
library(dplyr)
library(knitr)
library(tidyr) 
set.seed(137926)
pollution_complete <- read_csv("pollution.csv")
row.has.na <- apply(pollution_complete, 1, function(x){any(is.na(x))})
pollution <- pollution_complete[!row.has.na,]
numero_NA <- dim(pollution_complete)[1] -dim(pollution)[1]

pollution<- pollution[order( pollution$year, pollution$month,pollution$day),]
totales<- dim(pollution)[1]

#queremos saber que variables son categoricas y cuales numericas
classes <- sapply(pollution, function(x) class(x))
categoric_cols <- pollution[,which(classes %in% c("character", "factor"))]
numeric_cols <- pollution[, -which(classes %in% c("character", "factor"))]

#cuantos valores unicos --cardinalidad
uniques_num <- sapply(numeric_cols, function(x) unique(x) %>% length())
uniques_num <- as.data.frame(uniques_num)

uniques_cat <- sapply(categoric_cols, function(x) unique(x) %>% length())
uniques_cat <- as.data.frame(uniques_cat)

#valores unicos
uniques_values_num <- sapply(numeric_cols, function(x) unique(x))
uniques_values_cat <- sapply(categoric_cols, function(x) unique(x))

#proporcion valores unicos - uniqueness
uniqueness_num <-  round(uniques_num/totales * 100, 2)
uniqueness_num <- as.data.frame(uniqueness_num)

uniqueness_cat <-  round(uniques_cat/totales * 100, 2)
uniqueness_cat <- as.data.frame(uniqueness_cat)
                                
#checamos si hay vacios 
nan_num <- sapply(numeric_cols, function(x) sum(is.na(x)))
nan_num <- as.data.frame(nan_num)

nan_cat <- sapply(categoric_cols, function(x) sum(is.na(x)))
nan_cat <- as.data.frame(nan_cat)

#para sacar la moda, redondeamos a 2 digitos
my_mode <- function(x){
  if (class(x) %in% c("character", "factor")) {
    table(x) %>%
      which.max() %>%
      names()
  }
  else {
    table(round(x, 2)) %>%
      which.max() %>%
      names()
  }
}


#moda
modes_num <- sapply(numeric_cols, function(x) my_mode(x))
modes_num <- as.data.frame(modes_num)

modes_cat <- sapply(categoric_cols, function(x) my_mode(x))
modes_cat <- as.data.frame(modes_cat)


#min 
mins <- sapply(numeric_cols, function(x) min(x))
mins <- as.data.frame(mins)

#max
maxs <- sapply(numeric_cols, function(x) max(x))
maxs <- as.data.frame(maxs)

#mean
means <- sapply(numeric_cols, function(x) mean(x))
means <- as.data.frame(means)

#median
medians <- sapply(numeric_cols, function(x) median(x))
medians <- as.data.frame(medians)

#1st quantile
first_qtls <- sapply(numeric_cols, function(x) quantile(x)[2]) #revisa la funcion quantile!
first_qtls <- as.data.frame(first_qtls)

#3rd quantile
third_qtls <- sapply(numeric_cols, function(x) quantile(x)[4]) 
third_qtls <- as.data.frame(third_qtls)

#sd
sds <- sapply(numeric_cols, function(x) sd(x))
sds <- as.data.frame(sds)

###generamos nuestra tabla de data profiling
df_categoric <- cbind(uniques_cat, uniqueness_cat, nan_cat, modes_cat)
#no me gusta que tengan en la columna cat... 
names(df_categoric) <- str_replace_all(names(df_categoric), "_cat", "")
names(df_categoric)[2]<-"uniqueness"

df_numeric <- cbind(uniques_num, uniqueness_num, nan_num, mins, maxs, means,
                    sds, medians, modes_num, first_qtls, third_qtls) 
names(df_numeric) <- str_replace_all(names(df_numeric), "_num", "")
names(df_numeric)[2]<-"uniqueness"
```


### Introducción al problema


Una investigación del Colegio del Medio Ambiente de la Universidad de Nanjing relacionó la contaminación con casi un tercio de todas las muertes que se producen en China, ubicando a la polución en el mismo nivel que fumar tabaco como amenaza para la salud pública. El estudio analiza casi 3 millones de muertes en 74 ciudades chinas durante 2013. Los hallazgos revelan que un 31,8% de todas las muertes registradas podrían estar relacionadas con la contaminación, con las grandes de ciudades de Hebei, la provincia que rodea a Beijing, clasificadas entre las peores.[Extraído de CNN](http://cnnespanol.cnn.com/2017/01/17/la-contaminacion-en-beijing-la-ciudad-donde-ricos-y-pobres-no-respiran-el-mismo-aire/).

Debido a los grandes problemas que ha causado la contaminación en China y la gran importancia en la salud que tiene, nosotros buscaremos analizar y predecir los niveles de contaminación en la ciudad de Beijing usando métodos de regresión. A lo largo de este trabajo estaremos trabajando con una base de datos que contiene información relacionada a la contaminación de Beijing del 1 de enero de 2010 al 31 de diciembre del 2014, y buscaremos ver que tan bien podemos predecir los niveles de contaminación del año 2014, a partir de los años 2010, 2011, 2012 y 2013.

Nuestra base de datos contiene **`r dim(pollution_complete)[1]`** registros, sin embargo, haciendo un pequeño análisis, vemos que contiene **`r numero_NA`** registros con información faltante. Como nuestro modelo es de regresión nosotros eliminaremos esos registros, para solo trabajar con información consistente. Además, nuestra base de datos contiene las siguientes columnas:

```{r echo=TRUE, warning=FALSE, message=FALSE, error=FALSE}
colnames(pollution)
```

Donde:
+ **No:** Número de Registro
+ **year:** Año en el que se hizo el registro
+ **month:** Mes en el que se hizo el registro
+ **day:** Día en el que se hizo el registro
+ **hour:** Hora en el que se hizo el registro
+ **pm2.5:** Concentración de PM2.5 
+ **DEWP:** Punto de rocío
+ **TEMP:** Temperatura
+ ** PRES: ** Presión
+ **cbwd:** Dirección del aire combinada
+ **lws:** Velocidad del aire acumulada
+ **Is:** Horas acumuladas de nieve
+ **Ir:** Horas acumuladas de lluvia

***
### Data Profiling

Hagamos un analisis de las variables categóricas:

```{r echo=T, warning=F, error=F, message=F}
kable(df_categoric, format.args = list(big.mark=",", scientific=F))
```
La única variable categórica que tenemos es 'cbwd' que nos muestra practicamente la dirección del aire. Sin embargo no nos proporciona mucha información relevante, más que la dirección del viento mas predominante es 'SouthEast'

A continuacion analicemos las variables numericas:


```{r echo=T, warning=F, error=F, message=F}
kable(df_numeric, format.args = list(big.mark=",", scientific=F))
```


***

###EDA

```{r echo=FALSE, warning=FALSE, error=FALSE, message=FALSE}
ggplot(pollution,aes(x = pm2.5, y =year ))+geom_point()+ggtitle("PM2.5 vs Año")
ggplot(pollution,aes(x = pm2.5, y =month ))+geom_point()+ggtitle("PM2.5 vs Mes")
ggplot(pollution,aes(x = pm2.5, y =day ))+geom_point()+ggtitle("PM2.5 vs Día")
ggplot(pollution,aes(x = pm2.5, y =hour ))+geom_point()+ggtitle("PM2.5 vs Hora")
ggplot(pollution,aes(x = pm2.5, y =DEWP ))+geom_point()+ggtitle("PM2.5 vs DEWP")
ggplot(pollution,aes(x = pm2.5, y =TEMP ))+geom_point()+ggtitle("PM2.5 vs TEMP")
ggplot(pollution,aes(x = pm2.5, y =PRES ))+geom_point()+ggtitle("PM2.5 vs PRES")
ggplot(pollution,aes(x = pm2.5, y =Iws ))+geom_point()+ggtitle("PM2.5 vs Isw")
ggplot(pollution,aes(x = pm2.5, y =Is ))+geom_point()+ggtitle("PM2.5 vs Is")
ggplot(pollution,aes(x = pm2.5, y =Ir ))+geom_point()+ggtitle("PM2.5 vs Ir")
```

```{r echo=TRUE, warning=FALSE, error=FALSE, message=FALSE}
corr_pol <- pollution[, -10]
corr_pol <- corr_pol[,-1]
cor(corr_pol)
```

Las variables que parecen tener mejor relación lineal con la variable objetivo (PM2.5) son DEWP e Isw ya que se nota una tendencia al graficarlas contra la variable que estamos estudiando. Las demás variables sí tienen relación lineal pero muy pequeña, se realizará la regresión lineal con todas las variables que se tienen para después empezar descartar las variables que menos relación tienen con la variable analizada; las variables que menos relación tienen y que son las candidatas a ser eliminadas de la regresión son: Año e IS.

```{r echo=TRUE, warning=FALSE, error=FALSE, message=FALSE}
out_year <- boxplot(pollution$year, plot=F)
out_month <- boxplot(pollution$month, plot=F)
out_day <- boxplot(pollution$day, plot=F)
out_hour <- boxplot(pollution$hour, plot=F)
out_DEWP <- boxplot(pollution$DEWP, plot=F)
out_TEMP <- boxplot(pollution$TEMP, plot=F)
out_PRES <- boxplot(pollution$PRES, plot=F)
out_Iws <- boxplot(pollution$Iws, plot=F)
out_Is <- boxplot(pollution$Is, plot=F)
out_Ir <- boxplot(pollution$Ir, plot=F)
```



El número de outliers de cada variable son:

  + year: **`r length(out_year$out)`**
  + month: **`r length(out_month$out)`** 
  + day: **`r length(out_day$out)`**
  + hour: **`r length(out_hour$out)`**
  + DEWP: **`r length(out_DEWP$out)`**
  + TEMP: **`r length(out_TEMP$out)`**
  + PRES: **`r length(out_PRES$out)`**
  + Iws: **`r length(out_Iws$out)`**
  + Is: **`r length(out_Is$out)`**
  + Ir: **`r length(out_Ir$out)`**


Después sacar la cantidad de datos atípicos de cada variable se puede ver que solo las variables Isw, Is e Ir los presentan. Se debe considerar eliminar los datos atípicos de Iws porque es una de las variables que mayor relación tiene con la variable que estamos analizando; los datos atípicos de las demás variables no son necesarios de eliminar porque son variables que no proporcionarán tanta información a la regresión lineal.

***